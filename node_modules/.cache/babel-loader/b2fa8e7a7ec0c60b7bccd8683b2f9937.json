{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Frame = exports.FrameManager = exports.FrameManagerEmittedEvents = void 0;\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\n\nconst DOMWorld_js_1 = require(\"./DOMWorld.js\");\n\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\n\nconst Connection_js_1 = require(\"./Connection.js\");\n\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\nconst xPathPattern = /^\\(\\/\\/[^\\)]+\\)|^\\/\\//;\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\nexports.FrameManagerEmittedEvents = {\n  FrameAttached: Symbol('FrameManager.FrameAttached'),\n  FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n  FrameDetached: Symbol('FrameManager.FrameDetached'),\n  LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n  FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n  ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n  ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed')\n};\n/**\n * @internal\n */\n\nclass FrameManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this._frames = new Map();\n    this._contextIdToContext = new Map();\n    this._isolatedWorlds = new Set();\n    this._client = client;\n    this._page = page;\n    this._networkManager = new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this);\n    this._timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this._client);\n  }\n\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', event => {\n      this._onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', event => {\n      this._onFrameNavigated(event.frame);\n    });\n    session.on('Page.navigatedWithinDocument', event => {\n      this._onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', event => {\n      this._onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStoppedLoading', event => {\n      this._onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', event => {\n      this._onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', event => {\n      this._onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', () => {\n      this._onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', event => {\n      this._onLifecycleEvent(event);\n    });\n    session.on('Target.attachedToTarget', async event => {\n      this._onAttachedToTarget(event);\n    });\n    session.on('Target.detachedFromTarget', async event => {\n      this._onDetachedFromTarget(event);\n    });\n  }\n\n  async initialize(client = this._client) {\n    try {\n      const result = await Promise.all([client.send('Page.enable'), client.send('Page.getFrameTree')]);\n      const {\n        frameTree\n      } = result[1];\n\n      this._handleFrameTree(client, frameTree);\n\n      await Promise.all([client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => this._ensureIsolatedWorld(client, UTILITY_WORLD_NAME)), // TODO: Network manager is not aware of OOP iframes yet.\n      client === this._client ? this._networkManager.initialize() : Promise.resolve()]);\n    } catch (error) {\n      // The target might have been closed before the initialization finished.\n      if (error.message.includes('Target closed') || error.message.includes('Session closed')) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  networkManager() {\n    return this._networkManager;\n  }\n\n  async navigateFrame(frame, url, options = {}) {\n    assertNoLegacyNavigationOptions(options);\n    const {\n      referer = this._networkManager.extraHTTPHeaders()['referer'],\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options;\n    const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n    let ensureNewDocumentNavigation = false;\n    let error = await Promise.race([navigate(this._client, url, referer, frame._id), watcher.timeoutOrTerminationPromise()]);\n\n    if (!error) {\n      error = await Promise.race([watcher.timeoutOrTerminationPromise(), ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()]);\n    }\n\n    watcher.dispose();\n    if (error) throw error;\n    return watcher.navigationResponse();\n\n    async function navigate(client, url, referrer, frameId) {\n      try {\n        const response = await client.send('Page.navigate', {\n          url,\n          referrer,\n          frameId\n        });\n        ensureNewDocumentNavigation = !!response.loaderId;\n        return response.errorText ? new Error(`${response.errorText} at ${url}`) : null;\n      } catch (error) {\n        return error;\n      }\n    }\n  }\n\n  async waitForFrameNavigation(frame, options = {}) {\n    assertNoLegacyNavigationOptions(options);\n    const {\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options;\n    const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n    const error = await Promise.race([watcher.timeoutOrTerminationPromise(), watcher.sameDocumentNavigationPromise(), watcher.newDocumentNavigationPromise()]);\n    watcher.dispose();\n    if (error) throw error;\n    return watcher.navigationResponse();\n  }\n\n  async _onAttachedToTarget(event) {\n    if (event.targetInfo.type !== 'iframe') {\n      return;\n    }\n\n    const frame = this._frames.get(event.targetInfo.targetId);\n\n    const session = Connection_js_1.Connection.fromSession(this._client).session(event.sessionId);\n\n    frame._updateClient(session);\n\n    this.setupEventListeners(session);\n    await this.initialize(session);\n  }\n\n  async _onDetachedFromTarget(event) {\n    const frame = this._frames.get(event.targetId);\n\n    if (frame && frame.isOOPFrame()) {\n      // When an OOP iframe is removed from the page, it\n      // will only get a Target.detachedFromTarget event.\n      this._removeFramesRecursively(frame);\n    }\n  }\n\n  _onLifecycleEvent(event) {\n    const frame = this._frames.get(event.frameId);\n\n    if (!frame) return;\n\n    frame._onLifecycleEvent(event.loaderId, event.name);\n\n    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _onFrameStoppedLoading(frameId) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._onLoadingStopped();\n\n    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this._onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n\n    this._onFrameNavigated(frameTree.frame);\n\n    if (!frameTree.childFrames) return;\n\n    for (const child of frameTree.childFrames) {\n      this._handleFrameTree(session, child);\n    }\n  }\n\n  page() {\n    return this._page;\n  }\n\n  mainFrame() {\n    return this._mainFrame;\n  }\n\n  frames() {\n    return Array.from(this._frames.values());\n  }\n\n  frame(frameId) {\n    return this._frames.get(frameId) || null;\n  }\n\n  _onFrameAttached(session, frameId, parentFrameId) {\n    if (this._frames.has(frameId)) {\n      const frame = this._frames.get(frameId);\n\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame._updateClient(session);\n      }\n\n      return;\n    }\n\n    (0, assert_js_1.assert)(parentFrameId);\n\n    const parentFrame = this._frames.get(parentFrameId);\n\n    const frame = new Frame(this, parentFrame, frameId, session);\n\n    this._frames.set(frame._id, frame);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);\n  }\n\n  _onFrameNavigated(framePayload) {\n    const isMainFrame = !framePayload.parentId;\n    let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);\n    (0, assert_js_1.assert)(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame'); // Detach all child frames first.\n\n    if (frame) {\n      for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n    } // Update or create main frame.\n\n\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(frame._id);\n\n        frame._id = framePayload.id;\n      } else {\n        // Initial main frame navigation.\n        frame = new Frame(this, null, framePayload.id, this._client);\n      }\n\n      this._frames.set(framePayload.id, frame);\n\n      this._mainFrame = frame;\n    } // Update frame payload.\n\n\n    frame._navigated(framePayload);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  async _ensureIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this._isolatedWorlds.has(key)) return;\n\n    this._isolatedWorlds.add(key);\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,\n      worldName: name\n    }); // Frames might be removed before we send this.\n\n    await Promise.all(this.frames().filter(frame => frame._client === session).map(frame => session.send('Page.createIsolatedWorld', {\n      frameId: frame._id,\n      worldName: name,\n      grantUniveralAccess: true\n    })));\n  }\n\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._navigatedWithinDocument(url);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  _onFrameDetached(frameId, reason) {\n    const frame = this._frames.get(frameId);\n\n    if (reason === 'remove') {\n      // Only remove the frame if the reason for the detached event is\n      // an actual removement of the frame.\n      // For frames that become OOP iframes, the reason would be 'swap'.\n      if (frame) this._removeFramesRecursively(frame);\n    }\n  }\n\n  _onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData ? auxData.frameId : null;\n    const frame = this._frames.get(frameId) || null;\n    let world = null;\n\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame._client !== session) return;\n\n      if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n        world = frame._mainWorld;\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame._secondaryWorld._hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame._secondaryWorld;\n      }\n    }\n\n    const context = new ExecutionContext_js_1.ExecutionContext(frame._client || this._client, contextPayload, world);\n    if (world) world._setContext(context);\n    const key = `${session.id()}:${contextPayload.id}`;\n\n    this._contextIdToContext.set(key, context);\n  }\n\n  _onExecutionContextDestroyed(executionContextId, session) {\n    const key = `${session.id()}:${executionContextId}`;\n\n    const context = this._contextIdToContext.get(key);\n\n    if (!context) return;\n\n    this._contextIdToContext.delete(key);\n\n    if (context._world) context._world._setContext(null);\n  }\n\n  _onExecutionContextsCleared(session) {\n    for (const [key, context] of this._contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) continue;\n      if (context._world) context._world._setContext(null);\n\n      this._contextIdToContext.delete(key);\n    }\n  }\n\n  executionContextById(contextId, session = this._client) {\n    const key = `${session.id()}:${contextId}`;\n\n    const context = this._contextIdToContext.get(key);\n\n    (0, assert_js_1.assert)(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  _removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n\n    frame._detach();\n\n    this._frames.delete(frame._id);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);\n  }\n\n}\n\nexports.FrameManager = FrameManager;\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\n\nclass Frame {\n  /**\n   * @internal\n   */\n  constructor(frameManager, parentFrame, frameId, client) {\n    this._url = '';\n    this._detached = false;\n    /**\n     * @internal\n     */\n\n    this._loaderId = '';\n    /**\n     * @internal\n     */\n\n    this._lifecycleEvents = new Set();\n    this._frameManager = frameManager;\n    this._parentFrame = parentFrame;\n    this._url = '';\n    this._id = frameId;\n    this._detached = false;\n    this._loaderId = '';\n    this._childFrames = new Set();\n    if (this._parentFrame) this._parentFrame._childFrames.add(this);\n\n    this._updateClient(client);\n  }\n  /**\n   * @internal\n   */\n\n\n  _updateClient(client) {\n    this._client = client;\n    this._mainWorld = new DOMWorld_js_1.DOMWorld(this._client, this._frameManager, this, this._frameManager._timeoutSettings);\n    this._secondaryWorld = new DOMWorld_js_1.DOMWorld(this._client, this._frameManager, this, this._frameManager._timeoutSettings);\n  }\n\n  isOOPFrame() {\n    return this._client !== this._frameManager._client;\n  }\n  /**\n   * @remarks\n   *\n   * `frame.goto` will throw an error if:\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   *\n   * - target URL is invalid.\n   *\n   * - the `timeout` is exceeded during navigation.\n   *\n   * - the remote server does not respond or is unreachable.\n   *\n   * - the main resource failed to load.\n   *\n   * `frame.goto` will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\".  The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   *\n   * NOTE: `frame.goto` either throws an error or returns a main resource\n   * response. The only exceptions are navigation to `about:blank` or\n   * navigation to the same URL with a different hash, which would succeed and\n   * return `null`.\n   *\n   * NOTE: Headless mode doesn't support navigation to a PDF document. See\n   * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * @param url - the URL to navigate the frame to. This should include the\n   * scheme, e.g. `https://`.\n   * @param options - navigation options. `waitUntil` is useful to define when\n   * the navigation should be considered successful - see the docs for\n   * {@link PuppeteerLifeCycleEvent} for more details.\n   *\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n\n\n  async goto(url, options = {}) {\n    return await this._frameManager.navigateFrame(this, url, options);\n  }\n  /**\n   * @remarks\n   *\n   * This resolves when the frame navigates to a new URL. It is useful for when\n   * you run code which will indirectly cause the frame to navigate. Consider\n   * this example:\n   *\n   * ```js\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n   *\n   * @param options - options to configure when the navigation is consided finished.\n   * @returns a promise that resolves when the frame navigates to a new URL.\n   */\n\n\n  async waitForNavigation(options = {}) {\n    return await this._frameManager.waitForFrameNavigation(this, options);\n  }\n  /**\n   * @returns a promise that resolves to the frame's default execution context.\n   */\n\n\n  executionContext() {\n    return this._mainWorld.executionContext();\n  }\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Frame.evaluate} and\n   * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * This method behaves identically to {@link Page.evaluateHandle} except it's\n   * run within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    return this._mainWorld.evaluateHandle(pageFunction, ...args);\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves identically to {@link Page.evaluate} except it's run\n   * within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return this._mainWorld.evaluate(pageFunction, ...args);\n  }\n  /**\n   * This method queries the frame for the given selector.\n   *\n   * @param selector - a selector to query for.\n   * @returns A promise which resolves to an `ElementHandle` pointing at the\n   * element, or `null` if it was not found.\n   */\n\n\n  async $(selector) {\n    return this._mainWorld.$(selector);\n  }\n  /**\n   * This method evaluates the given XPath expression and returns the results.\n   *\n   * @param expression - the XPath expression to evaluate.\n   */\n\n\n  async $x(expression) {\n    return this._mainWorld.$x(expression);\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `document.querySelector` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  async $eval(selector, pageFunction, ...args) {\n    return this._mainWorld.$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  async $$eval(selector, pageFunction, ...args) {\n    return this._mainWorld.$$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * This runs `document.querySelectorAll` in the frame and returns the result.\n   *\n   * @param selector - a selector to search for\n   * @returns An array of element handles pointing to the found frame elements.\n   */\n\n\n  async $$(selector) {\n    return this._mainWorld.$$(selector);\n  }\n  /**\n   * @returns the full HTML contents of the frame, including the doctype.\n   */\n\n\n  async content() {\n    return this._secondaryWorld.content();\n  }\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n\n\n  async setContent(html, options = {}) {\n    return this._secondaryWorld.setContent(html, options);\n  }\n  /**\n   * @remarks\n   *\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * Note: This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   *\n   * @returns the frame's `name` attribute as specified in the tag.\n   */\n\n\n  name() {\n    return this._name || '';\n  }\n  /**\n   * @returns the frame's URL.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n   */\n\n\n  parentFrame() {\n    return this._parentFrame;\n  }\n  /**\n   * @returns an array of child frames.\n   */\n\n\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n  /**\n   * @returns `true` if the frame has been detached, or `false` otherwise.\n   */\n\n\n  isDetached() {\n    return this._detached;\n  }\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - configure the script to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the script's\n   * `onload` event fires or when the script content was injected into the\n   * frame.\n   */\n\n\n  async addScriptTag(options) {\n    return this._mainWorld.addScriptTag(options);\n  }\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * @param options - configure the CSS to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the stylesheets's\n   * `onload` event fires or when the CSS content was injected into the\n   * frame.\n   */\n\n\n  async addStyleTag(options) {\n    return this._mainWorld.addStyleTag(options);\n  }\n  /**\n   *\n   * This method clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   *\n   * This method scrolls the element into view if needed, and then uses\n   * {@link Page.mouse} to click in the center of the element. If there's no\n   * element matching `selector`, the method throws an error.\n   *\n   * Bear in mind that if `click()` triggers a navigation event and there's a\n   * separate `page.waitForNavigation()` promise to be resolved, you may end up\n   * with a race condition that yields unexpected results. The correct pattern\n   * for click and wait for navigation is the following:\n   *\n   * ```javascript\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   * @param selector - the selector to search for to click. If there are\n   * multiple elements, the first will be clicked.\n   */\n\n\n  async click(selector, options = {}) {\n    return this._secondaryWorld.click(selector, options);\n  }\n  /**\n   * This method fetches an element with `selector` and focuses it.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector for the element to focus. If there are\n   * multiple elements, the first will be focused.\n   */\n\n\n  async focus(selector) {\n    return this._secondaryWorld.focus(selector);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse} to hover over the center of the\n   * element.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an\n   *\n   * @param selector - the selector for the element to hover. If there are\n   * multiple elements, the first will be hovered.\n   */\n\n\n  async hover(selector) {\n    return this._secondaryWorld.hover(selector);\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have\n   * been selected.\n   *\n   * @remarks\n   *\n   * If there's no `<select>` element matching `selector`, the\n   * method throws an error.\n   *\n   * @example\n   * ```js\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - a selector to query the frame for\n   * @param values - an array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   */\n\n\n  select(selector, ...values) {\n    return this._secondaryWorld.select(selector, ...values);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n   * element.\n   *\n   * @remarks\n   *\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector to tap.\n   * @returns a promise that resolves when the element has been tapped.\n   */\n\n\n  async tap(selector) {\n    return this._secondaryWorld.tap(selector);\n  }\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   * ```js\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   *\n   * @returns a promise that resolves when the typing is complete.\n   */\n\n\n  async type(selector, text, options) {\n    return this._mainWorld.type(selector, text, options);\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves differently depending on the first parameter. If it's a\n   * `string`, it will be treated as a `selector` or `xpath` (if the string\n   * starts with `//`). This method then is a shortcut for\n   * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n   *\n   * If the first argument is a function this method is a shortcut for\n   * {@link Frame.waitForFunction}.\n   *\n   * If the first argument is a `number`, it's treated as a timeout in\n   * milliseconds and the method returns a promise which resolves after the\n   * timeout.\n   *\n   * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n   * wait for.\n   * @param options - optional waiting parameters.\n   * @param args - arguments to pass to `pageFunction`.\n   *\n   * @deprecated Don't use this method directly. Instead use the more explicit\n   * methods available: {@link Frame.waitForSelector},\n   * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n   * {@link Frame.waitForTimeout}.\n   */\n\n\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n\n    if (helper_js_1.helper.isString(selectorOrFunctionOrTimeout)) {\n      const string = selectorOrFunctionOrTimeout;\n      if (xPathPattern.test(string)) return this.waitForXPath(string, options);\n      return this.waitForSelector(string, options);\n    }\n\n    if (helper_js_1.helper.isNumber(selectorOrFunctionOrTimeout)) return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n    if (typeof selectorOrFunctionOrTimeout === 'function') return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n    return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n  }\n  /**\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n\n\n  waitForTimeout(milliseconds) {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n  /**\n   * @remarks\n   *\n   *\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately.\n   * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n   * the function will throw.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page.mainFrame()\n   *   .waitForSelector('img')\n   *   .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   * @param selector - the selector to wait for.\n   * @param options - options to define if the element should be visible and how\n   * long to wait before timing out.\n   * @returns a promise which resolves when an element matching the selector\n   * string is added to the DOM.\n   */\n\n\n  async waitForSelector(selector, options = {}) {\n    const handle = await this._secondaryWorld.waitForSelector(selector, options);\n    if (!handle) return null;\n    const mainExecutionContext = await this._mainWorld.executionContext();\n    const result = await mainExecutionContext._adoptElementHandle(handle);\n    await handle.dispose();\n    return result;\n  }\n  /**\n   * @remarks\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options  - options to configure the visiblity of the element and how\n   * long to wait before timing out.\n   */\n\n\n  async waitForXPath(xpath, options = {}) {\n    const handle = await this._secondaryWorld.waitForXPath(xpath, options);\n    if (!handle) return null;\n    const mainExecutionContext = await this._mainWorld.executionContext();\n    const result = await mainExecutionContext._adoptElementHandle(handle);\n    await handle.dispose();\n    return result;\n  }\n  /**\n   * @remarks\n   *\n   * @example\n   *\n   * The `waitForFunction` can be used to observe viewport size change:\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```js\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   *);\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n  }\n  /**\n   * @returns the frame's title.\n   */\n\n\n  async title() {\n    return this._secondaryWorld.title();\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigated(framePayload) {\n    this._name = framePayload.name;\n    this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigatedWithinDocument(url) {\n    this._url = url;\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLifecycleEvent(loaderId, name) {\n    if (name === 'init') {\n      this._loaderId = loaderId;\n\n      this._lifecycleEvents.clear();\n    }\n\n    this._lifecycleEvents.add(name);\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLoadingStopped() {\n    this._lifecycleEvents.add('DOMContentLoaded');\n\n    this._lifecycleEvents.add('load');\n  }\n  /**\n   * @internal\n   */\n\n\n  _detach() {\n    this._detached = true;\n\n    this._mainWorld._detach();\n\n    this._secondaryWorld._detach();\n\n    if (this._parentFrame) this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n\n}\n\nexports.Frame = Frame;\n\nfunction assertNoLegacyNavigationOptions(options) {\n  (0, assert_js_1.assert)(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n  (0, assert_js_1.assert)(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n  (0, assert_js_1.assert)(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n}","map":{"version":3,"sources":["../../../../src/common/FrameManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Frame = exports.FrameManager = exports.FrameManagerEmittedEvents = void 0;\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\nconst DOMWorld_js_1 = require(\"./DOMWorld.js\");\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\nconst xPathPattern = /^\\(\\/\\/[^\\)]+\\)|^\\/\\//;\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.FrameManagerEmittedEvents = {\n    FrameAttached: Symbol('FrameManager.FrameAttached'),\n    FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n    FrameDetached: Symbol('FrameManager.FrameDetached'),\n    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n    ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n    ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),\n};\n/**\n * @internal\n */\nclass FrameManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n        super();\n        this._frames = new Map();\n        this._contextIdToContext = new Map();\n        this._isolatedWorlds = new Set();\n        this._client = client;\n        this._page = page;\n        this._networkManager = new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this);\n        this._timeoutSettings = timeoutSettings;\n        this.setupEventListeners(this._client);\n    }\n    setupEventListeners(session) {\n        session.on('Page.frameAttached', (event) => {\n            this._onFrameAttached(session, event.frameId, event.parentFrameId);\n        });\n        session.on('Page.frameNavigated', (event) => {\n            this._onFrameNavigated(event.frame);\n        });\n        session.on('Page.navigatedWithinDocument', (event) => {\n            this._onFrameNavigatedWithinDocument(event.frameId, event.url);\n        });\n        session.on('Page.frameDetached', (event) => {\n            this._onFrameDetached(event.frameId, event.reason);\n        });\n        session.on('Page.frameStoppedLoading', (event) => {\n            this._onFrameStoppedLoading(event.frameId);\n        });\n        session.on('Runtime.executionContextCreated', (event) => {\n            this._onExecutionContextCreated(event.context, session);\n        });\n        session.on('Runtime.executionContextDestroyed', (event) => {\n            this._onExecutionContextDestroyed(event.executionContextId, session);\n        });\n        session.on('Runtime.executionContextsCleared', () => {\n            this._onExecutionContextsCleared(session);\n        });\n        session.on('Page.lifecycleEvent', (event) => {\n            this._onLifecycleEvent(event);\n        });\n        session.on('Target.attachedToTarget', async (event) => {\n            this._onAttachedToTarget(event);\n        });\n        session.on('Target.detachedFromTarget', async (event) => {\n            this._onDetachedFromTarget(event);\n        });\n    }\n    async initialize(client = this._client) {\n        try {\n            const result = await Promise.all([\n                client.send('Page.enable'),\n                client.send('Page.getFrameTree'),\n            ]);\n            const { frameTree } = result[1];\n            this._handleFrameTree(client, frameTree);\n            await Promise.all([\n                client.send('Page.setLifecycleEventsEnabled', { enabled: true }),\n                client\n                    .send('Runtime.enable')\n                    .then(() => this._ensureIsolatedWorld(client, UTILITY_WORLD_NAME)),\n                // TODO: Network manager is not aware of OOP iframes yet.\n                client === this._client\n                    ? this._networkManager.initialize()\n                    : Promise.resolve(),\n            ]);\n        }\n        catch (error) {\n            // The target might have been closed before the initialization finished.\n            if (error.message.includes('Target closed') ||\n                error.message.includes('Session closed')) {\n                return;\n            }\n            throw error;\n        }\n    }\n    networkManager() {\n        return this._networkManager;\n    }\n    async navigateFrame(frame, url, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { referer = this._networkManager.extraHTTPHeaders()['referer'], waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n        let ensureNewDocumentNavigation = false;\n        let error = await Promise.race([\n            navigate(this._client, url, referer, frame._id),\n            watcher.timeoutOrTerminationPromise(),\n        ]);\n        if (!error) {\n            error = await Promise.race([\n                watcher.timeoutOrTerminationPromise(),\n                ensureNewDocumentNavigation\n                    ? watcher.newDocumentNavigationPromise()\n                    : watcher.sameDocumentNavigationPromise(),\n            ]);\n        }\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n        async function navigate(client, url, referrer, frameId) {\n            try {\n                const response = await client.send('Page.navigate', {\n                    url,\n                    referrer,\n                    frameId,\n                });\n                ensureNewDocumentNavigation = !!response.loaderId;\n                return response.errorText\n                    ? new Error(`${response.errorText} at ${url}`)\n                    : null;\n            }\n            catch (error) {\n                return error;\n            }\n        }\n    }\n    async waitForFrameNavigation(frame, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n        const error = await Promise.race([\n            watcher.timeoutOrTerminationPromise(),\n            watcher.sameDocumentNavigationPromise(),\n            watcher.newDocumentNavigationPromise(),\n        ]);\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n    }\n    async _onAttachedToTarget(event) {\n        if (event.targetInfo.type !== 'iframe') {\n            return;\n        }\n        const frame = this._frames.get(event.targetInfo.targetId);\n        const session = Connection_js_1.Connection.fromSession(this._client).session(event.sessionId);\n        frame._updateClient(session);\n        this.setupEventListeners(session);\n        await this.initialize(session);\n    }\n    async _onDetachedFromTarget(event) {\n        const frame = this._frames.get(event.targetId);\n        if (frame && frame.isOOPFrame()) {\n            // When an OOP iframe is removed from the page, it\n            // will only get a Target.detachedFromTarget event.\n            this._removeFramesRecursively(frame);\n        }\n    }\n    _onLifecycleEvent(event) {\n        const frame = this._frames.get(event.frameId);\n        if (!frame)\n            return;\n        frame._onLifecycleEvent(event.loaderId, event.name);\n        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _onFrameStoppedLoading(frameId) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._onLoadingStopped();\n        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _handleFrameTree(session, frameTree) {\n        if (frameTree.frame.parentId) {\n            this._onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n        }\n        this._onFrameNavigated(frameTree.frame);\n        if (!frameTree.childFrames)\n            return;\n        for (const child of frameTree.childFrames) {\n            this._handleFrameTree(session, child);\n        }\n    }\n    page() {\n        return this._page;\n    }\n    mainFrame() {\n        return this._mainFrame;\n    }\n    frames() {\n        return Array.from(this._frames.values());\n    }\n    frame(frameId) {\n        return this._frames.get(frameId) || null;\n    }\n    _onFrameAttached(session, frameId, parentFrameId) {\n        if (this._frames.has(frameId)) {\n            const frame = this._frames.get(frameId);\n            if (session && frame.isOOPFrame()) {\n                // If an OOP iframes becomes a normal iframe again\n                // it is first attached to the parent page before\n                // the target is removed.\n                frame._updateClient(session);\n            }\n            return;\n        }\n        (0, assert_js_1.assert)(parentFrameId);\n        const parentFrame = this._frames.get(parentFrameId);\n        const frame = new Frame(this, parentFrame, frameId, session);\n        this._frames.set(frame._id, frame);\n        this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);\n    }\n    _onFrameNavigated(framePayload) {\n        const isMainFrame = !framePayload.parentId;\n        let frame = isMainFrame\n            ? this._mainFrame\n            : this._frames.get(framePayload.id);\n        (0, assert_js_1.assert)(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');\n        // Detach all child frames first.\n        if (frame) {\n            for (const child of frame.childFrames())\n                this._removeFramesRecursively(child);\n        }\n        // Update or create main frame.\n        if (isMainFrame) {\n            if (frame) {\n                // Update frame id to retain frame identity on cross-process navigation.\n                this._frames.delete(frame._id);\n                frame._id = framePayload.id;\n            }\n            else {\n                // Initial main frame navigation.\n                frame = new Frame(this, null, framePayload.id, this._client);\n            }\n            this._frames.set(framePayload.id, frame);\n            this._mainFrame = frame;\n        }\n        // Update frame payload.\n        frame._navigated(framePayload);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    async _ensureIsolatedWorld(session, name) {\n        const key = `${session.id()}:${name}`;\n        if (this._isolatedWorlds.has(key))\n            return;\n        this._isolatedWorlds.add(key);\n        await session.send('Page.addScriptToEvaluateOnNewDocument', {\n            source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,\n            worldName: name,\n        });\n        // Frames might be removed before we send this.\n        await Promise.all(this.frames()\n            .filter((frame) => frame._client === session)\n            .map((frame) => session.send('Page.createIsolatedWorld', {\n            frameId: frame._id,\n            worldName: name,\n            grantUniveralAccess: true,\n        })));\n    }\n    _onFrameNavigatedWithinDocument(frameId, url) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._navigatedWithinDocument(url);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    _onFrameDetached(frameId, reason) {\n        const frame = this._frames.get(frameId);\n        if (reason === 'remove') {\n            // Only remove the frame if the reason for the detached event is\n            // an actual removement of the frame.\n            // For frames that become OOP iframes, the reason would be 'swap'.\n            if (frame)\n                this._removeFramesRecursively(frame);\n        }\n    }\n    _onExecutionContextCreated(contextPayload, session) {\n        const auxData = contextPayload.auxData;\n        const frameId = auxData ? auxData.frameId : null;\n        const frame = this._frames.get(frameId) || null;\n        let world = null;\n        if (frame) {\n            // Only care about execution contexts created for the current session.\n            if (frame._client !== session)\n                return;\n            if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n                world = frame._mainWorld;\n            }\n            else if (contextPayload.name === UTILITY_WORLD_NAME &&\n                !frame._secondaryWorld._hasContext()) {\n                // In case of multiple sessions to the same target, there's a race between\n                // connections so we might end up creating multiple isolated worlds.\n                // We can use either.\n                world = frame._secondaryWorld;\n            }\n        }\n        const context = new ExecutionContext_js_1.ExecutionContext(frame._client || this._client, contextPayload, world);\n        if (world)\n            world._setContext(context);\n        const key = `${session.id()}:${contextPayload.id}`;\n        this._contextIdToContext.set(key, context);\n    }\n    _onExecutionContextDestroyed(executionContextId, session) {\n        const key = `${session.id()}:${executionContextId}`;\n        const context = this._contextIdToContext.get(key);\n        if (!context)\n            return;\n        this._contextIdToContext.delete(key);\n        if (context._world)\n            context._world._setContext(null);\n    }\n    _onExecutionContextsCleared(session) {\n        for (const [key, context] of this._contextIdToContext.entries()) {\n            // Make sure to only clear execution contexts that belong\n            // to the current session.\n            if (context._client !== session)\n                continue;\n            if (context._world)\n                context._world._setContext(null);\n            this._contextIdToContext.delete(key);\n        }\n    }\n    executionContextById(contextId, session = this._client) {\n        const key = `${session.id()}:${contextId}`;\n        const context = this._contextIdToContext.get(key);\n        (0, assert_js_1.assert)(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n        return context;\n    }\n    _removeFramesRecursively(frame) {\n        for (const child of frame.childFrames())\n            this._removeFramesRecursively(child);\n        frame._detach();\n        this._frames.delete(frame._id);\n        this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);\n    }\n}\nexports.FrameManager = FrameManager;\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\nclass Frame {\n    /**\n     * @internal\n     */\n    constructor(frameManager, parentFrame, frameId, client) {\n        this._url = '';\n        this._detached = false;\n        /**\n         * @internal\n         */\n        this._loaderId = '';\n        /**\n         * @internal\n         */\n        this._lifecycleEvents = new Set();\n        this._frameManager = frameManager;\n        this._parentFrame = parentFrame;\n        this._url = '';\n        this._id = frameId;\n        this._detached = false;\n        this._loaderId = '';\n        this._childFrames = new Set();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.add(this);\n        this._updateClient(client);\n    }\n    /**\n     * @internal\n     */\n    _updateClient(client) {\n        this._client = client;\n        this._mainWorld = new DOMWorld_js_1.DOMWorld(this._client, this._frameManager, this, this._frameManager._timeoutSettings);\n        this._secondaryWorld = new DOMWorld_js_1.DOMWorld(this._client, this._frameManager, this, this._frameManager._timeoutSettings);\n    }\n    isOOPFrame() {\n        return this._client !== this._frameManager._client;\n    }\n    /**\n     * @remarks\n     *\n     * `frame.goto` will throw an error if:\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     *\n     * - target URL is invalid.\n     *\n     * - the `timeout` is exceeded during navigation.\n     *\n     * - the remote server does not respond or is unreachable.\n     *\n     * - the main resource failed to load.\n     *\n     * `frame.goto` will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\".  The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     *\n     * NOTE: `frame.goto` either throws an error or returns a main resource\n     * response. The only exceptions are navigation to `about:blank` or\n     * navigation to the same URL with a different hash, which would succeed and\n     * return `null`.\n     *\n     * NOTE: Headless mode doesn't support navigation to a PDF document. See\n     * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * @param url - the URL to navigate the frame to. This should include the\n     * scheme, e.g. `https://`.\n     * @param options - navigation options. `waitUntil` is useful to define when\n     * the navigation should be considered successful - see the docs for\n     * {@link PuppeteerLifeCycleEvent} for more details.\n     *\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     */\n    async goto(url, options = {}) {\n        return await this._frameManager.navigateFrame(this, url, options);\n    }\n    /**\n     * @remarks\n     *\n     * This resolves when the frame navigates to a new URL. It is useful for when\n     * you run code which will indirectly cause the frame to navigate. Consider\n     * this example:\n     *\n     * ```js\n     * const [response] = await Promise.all([\n     *   // The navigation promise resolves after navigation has finished\n     *   frame.waitForNavigation(),\n     *   // Clicking the link will indirectly cause a navigation\n     *   frame.click('a.my-link'),\n     * ]);\n     * ```\n     *\n     * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n     *\n     * @param options - options to configure when the navigation is consided finished.\n     * @returns a promise that resolves when the frame navigates to a new URL.\n     */\n    async waitForNavigation(options = {}) {\n        return await this._frameManager.waitForFrameNavigation(this, options);\n    }\n    /**\n     * @returns a promise that resolves to the frame's default execution context.\n     */\n    executionContext() {\n        return this._mainWorld.executionContext();\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Frame.evaluate} and\n     * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * This method behaves identically to {@link Page.evaluateHandle} except it's\n     * run within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return this._mainWorld.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves identically to {@link Page.evaluate} except it's run\n     * within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluate(pageFunction, ...args) {\n        return this._mainWorld.evaluate(pageFunction, ...args);\n    }\n    /**\n     * This method queries the frame for the given selector.\n     *\n     * @param selector - a selector to query for.\n     * @returns A promise which resolves to an `ElementHandle` pointing at the\n     * element, or `null` if it was not found.\n     */\n    async $(selector) {\n        return this._mainWorld.$(selector);\n    }\n    /**\n     * This method evaluates the given XPath expression and returns the results.\n     *\n     * @param expression - the XPath expression to evaluate.\n     */\n    async $x(expression) {\n        return this._mainWorld.$x(expression);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `document.querySelector` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const searchValue = await frame.$eval('#search', el => el.value);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const divsCounts = await frame.$$eval('div', divs => divs.length);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $$eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This runs `document.querySelectorAll` in the frame and returns the result.\n     *\n     * @param selector - a selector to search for\n     * @returns An array of element handles pointing to the found frame elements.\n     */\n    async $$(selector) {\n        return this._mainWorld.$$(selector);\n    }\n    /**\n     * @returns the full HTML contents of the frame, including the doctype.\n     */\n    async content() {\n        return this._secondaryWorld.content();\n    }\n    /**\n     * Set the content of the frame.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - options to configure how long before timing out and at\n     * what point to consider the content setting successful.\n     */\n    async setContent(html, options = {}) {\n        return this._secondaryWorld.setContent(html, options);\n    }\n    /**\n     * @remarks\n     *\n     * If the name is empty, it returns the `id` attribute instead.\n     *\n     * Note: This value is calculated once when the frame is created, and will not\n     * update if the attribute is changed later.\n     *\n     * @returns the frame's `name` attribute as specified in the tag.\n     */\n    name() {\n        return this._name || '';\n    }\n    /**\n     * @returns the frame's URL.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n     */\n    parentFrame() {\n        return this._parentFrame;\n    }\n    /**\n     * @returns an array of child frames.\n     */\n    childFrames() {\n        return Array.from(this._childFrames);\n    }\n    /**\n     * @returns `true` if the frame has been detached, or `false` otherwise.\n     */\n    isDetached() {\n        return this._detached;\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired url or content.\n     *\n     * @param options - configure the script to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the script's\n     * `onload` event fires or when the script content was injected into the\n     * frame.\n     */\n    async addScriptTag(options) {\n        return this._mainWorld.addScriptTag(options);\n    }\n    /**\n     * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n     * a `<style type=\"text/css\">` tag with the content.\n     *\n     * @param options - configure the CSS to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the stylesheets's\n     * `onload` event fires or when the CSS content was injected into the\n     * frame.\n     */\n    async addStyleTag(options) {\n        return this._mainWorld.addStyleTag(options);\n    }\n    /**\n     *\n     * This method clicks the first element found that matches `selector`.\n     *\n     * @remarks\n     *\n     * This method scrolls the element into view if needed, and then uses\n     * {@link Page.mouse} to click in the center of the element. If there's no\n     * element matching `selector`, the method throws an error.\n     *\n     * Bear in mind that if `click()` triggers a navigation event and there's a\n     * separate `page.waitForNavigation()` promise to be resolved, you may end up\n     * with a race condition that yields unexpected results. The correct pattern\n     * for click and wait for navigation is the following:\n     *\n     * ```javascript\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   frame.click(selector, clickOptions),\n     * ]);\n     * ```\n     * @param selector - the selector to search for to click. If there are\n     * multiple elements, the first will be clicked.\n     */\n    async click(selector, options = {}) {\n        return this._secondaryWorld.click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector for the element to focus. If there are\n     * multiple elements, the first will be focused.\n     */\n    async focus(selector) {\n        return this._secondaryWorld.focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse} to hover over the center of the\n     * element.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an\n     *\n     * @param selector - the selector for the element to hover. If there are\n     * multiple elements, the first will be hovered.\n     */\n    async hover(selector) {\n        return this._secondaryWorld.hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have\n     * been selected.\n     *\n     * @remarks\n     *\n     * If there's no `<select>` element matching `selector`, the\n     * method throws an error.\n     *\n     * @example\n     * ```js\n     * frame.select('select#colors', 'blue'); // single selection\n     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - a selector to query the frame for\n     * @param values - an array of values to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     * @returns the list of values that were successfully selected.\n     */\n    select(selector, ...values) {\n        return this._secondaryWorld.select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n     * element.\n     *\n     * @remarks\n     *\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector to tap.\n     * @returns a promise that resolves when the element has been tapped.\n     */\n    async tap(selector) {\n        return this._secondaryWorld.tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n     * in the text.\n     *\n     * @remarks\n     * To press a special key, like `Control` or `ArrowDown`, use\n     * {@link Keyboard.press}.\n     *\n     * @example\n     * ```js\n     * await frame.type('#mytextarea', 'Hello'); // Types instantly\n     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @param selector - the selector for the element to type into. If there are\n     * multiple the first will be used.\n     * @param text - text to type into the element\n     * @param options - takes one option, `delay`, which sets the time to wait\n     * between key presses in milliseconds. Defaults to `0`.\n     *\n     * @returns a promise that resolves when the typing is complete.\n     */\n    async type(selector, text, options) {\n        return this._mainWorld.type(selector, text, options);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves differently depending on the first parameter. If it's a\n     * `string`, it will be treated as a `selector` or `xpath` (if the string\n     * starts with `//`). This method then is a shortcut for\n     * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n     *\n     * If the first argument is a function this method is a shortcut for\n     * {@link Frame.waitForFunction}.\n     *\n     * If the first argument is a `number`, it's treated as a timeout in\n     * milliseconds and the method returns a promise which resolves after the\n     * timeout.\n     *\n     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n     * wait for.\n     * @param options - optional waiting parameters.\n     * @param args - arguments to pass to `pageFunction`.\n     *\n     * @deprecated Don't use this method directly. Instead use the more explicit\n     * methods available: {@link Frame.waitForSelector},\n     * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n     * {@link Frame.waitForTimeout}.\n     */\n    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n        console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n        if (helper_js_1.helper.isString(selectorOrFunctionOrTimeout)) {\n            const string = selectorOrFunctionOrTimeout;\n            if (xPathPattern.test(string))\n                return this.waitForXPath(string, options);\n            return this.waitForSelector(string, options);\n        }\n        if (helper_js_1.helper.isNumber(selectorOrFunctionOrTimeout))\n            return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n        if (typeof selectorOrFunctionOrTimeout === 'function')\n            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n        return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n    }\n    /**\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```\n     * await frame.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    waitForTimeout(milliseconds) {\n        return new Promise((resolve) => {\n            setTimeout(resolve, milliseconds);\n        });\n    }\n    /**\n     * @remarks\n     *\n     *\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately.\n     * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n     * the function will throw.\n     *\n     * This method works across navigations.\n     *\n     * @example\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page.mainFrame()\n     *   .waitForSelector('img')\n     *   .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     * @param selector - the selector to wait for.\n     * @param options - options to define if the element should be visible and how\n     * long to wait before timing out.\n     * @returns a promise which resolves when an element matching the selector\n     * string is added to the DOM.\n     */\n    async waitForSelector(selector, options = {}) {\n        const handle = await this._secondaryWorld.waitForSelector(selector, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     * Wait for the `xpath` to appear in page. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * For a code example, see the example for {@link Frame.waitForSelector}. That\n     * function behaves identically other than taking a CSS selector rather than\n     * an XPath.\n     *\n     * @param xpath - the XPath expression to wait for.\n     * @param options  - options to configure the visiblity of the element and how\n     * long to wait before timing out.\n     */\n    async waitForXPath(xpath, options = {}) {\n        const handle = await this._secondaryWorld.waitForXPath(xpath, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     *\n     * @example\n     *\n     * The `waitForFunction` can be used to observe viewport size change:\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     * .  const browser = await puppeteer.launch();\n     * .  const page = await browser.newPage();\n     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n     * .  page.setViewport({width: 50, height: 50});\n     * .  await watchDog;\n     * .  await browser.close();\n     * })();\n     * ```\n     *\n     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n     *\n     * ```js\n     * const selector = '.foo';\n     * await frame.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {}, // empty options object\n     *   selector\n     *);\n     * ```\n     *\n     * @param pageFunction - the function to evaluate in the frame context.\n     * @param options - options to configure the polling method and timeout.\n     * @param args - arguments to pass to the `pageFunction`.\n     * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n     */\n    waitForFunction(pageFunction, options = {}, ...args) {\n        return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n    }\n    /**\n     * @returns the frame's title.\n     */\n    async title() {\n        return this._secondaryWorld.title();\n    }\n    /**\n     * @internal\n     */\n    _navigated(framePayload) {\n        this._name = framePayload.name;\n        this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n    }\n    /**\n     * @internal\n     */\n    _navigatedWithinDocument(url) {\n        this._url = url;\n    }\n    /**\n     * @internal\n     */\n    _onLifecycleEvent(loaderId, name) {\n        if (name === 'init') {\n            this._loaderId = loaderId;\n            this._lifecycleEvents.clear();\n        }\n        this._lifecycleEvents.add(name);\n    }\n    /**\n     * @internal\n     */\n    _onLoadingStopped() {\n        this._lifecycleEvents.add('DOMContentLoaded');\n        this._lifecycleEvents.add('load');\n    }\n    /**\n     * @internal\n     */\n    _detach() {\n        this._detached = true;\n        this._mainWorld._detach();\n        this._secondaryWorld._detach();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.delete(this);\n        this._parentFrame = null;\n    }\n}\nexports.Frame = Frame;\nfunction assertNoLegacyNavigationOptions(options) {\n    (0, assert_js_1.assert)(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n    (0, assert_js_1.assert)(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n    (0, assert_js_1.assert)(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n}\n//# sourceMappingURL=FrameManager.js.map"]},"metadata":{},"sourceType":"script"}