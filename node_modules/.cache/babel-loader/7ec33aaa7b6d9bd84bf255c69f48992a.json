{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\n\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\n\nexports.NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\n\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    /*\n     * There are four possible orders of events:\n     *  A. `_onRequestWillBeSent`\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n     *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n     *     (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     *  A. `_onRequestWillBeSent`,\n     *     `_onRequestWillBeSent`, ...\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *     (see crbug.com/1196004)\n     */\n\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._requestIdToRequestPausedEvent = new Map();\n    this._requestIdToRequest = new Map();\n    this._extraHTTPHeaders = {};\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    this._emulatedNetworkConditions = {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    };\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  async initialize() {\n    await this._client.send('Network.enable');\n    if (this._ignoreHTTPSErrors) await this._client.send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    });\n  }\n\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      (0, assert_js_1.assert)(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n\n    await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: this._extraHTTPHeaders\n    });\n  }\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  numRequestsInProgress() {\n    return [...this._requestIdToRequest].filter(([, request]) => {\n      return !request.response();\n    }).length;\n  }\n\n  async setOfflineMode(value) {\n    this._emulatedNetworkConditions.offline = value;\n    await this._updateNetworkConditions();\n  }\n\n  async emulateNetworkConditions(networkConditions) {\n    this._emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n    this._emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n    this._emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n    await this._updateNetworkConditions();\n  }\n\n  async _updateNetworkConditions() {\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._emulatedNetworkConditions.offline,\n      latency: this._emulatedNetworkConditions.latency,\n      uploadThroughput: this._emulatedNetworkConditions.upload,\n      downloadThroughput: this._emulatedNetworkConditions.download\n    });\n  }\n\n  async setUserAgent(userAgent, userAgentMetadata) {\n    await this._client.send('Network.setUserAgentOverride', {\n      userAgent: userAgent,\n      userAgentMetadata: userAgentMetadata\n    });\n  }\n\n  async setCacheEnabled(enabled) {\n    this._userCacheDisabled = !enabled;\n    await this._updateProtocolCacheDisabled();\n  }\n\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n\n    if (enabled) {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.disable')]);\n    }\n  }\n\n  _cacheDisabled() {\n    return this._userCacheDisabled;\n  }\n\n  async _updateProtocolCacheDisabled() {\n    await this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: this._cacheDisabled()\n    });\n  }\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._userRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n\n      this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n\n      if (requestPausedEvent) {\n        const interceptionId = requestPausedEvent.requestId;\n\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToRequestPausedEvent.delete(requestId);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n\n  _onAuthRequired(event) {\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(helper_js_1.debugError);\n  }\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(helper_js_1.debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (!requestId) {\n      return;\n    }\n\n    let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId); // redirect requests have the same `requestId`,\n\n\n    if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      requestWillBeSentEvent = null;\n    }\n\n    if (requestWillBeSentEvent) {\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToRequestPausedEvent.set(requestId, event);\n    }\n  }\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n    request.finalizeInterceptions();\n  }\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n    this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);\n  }\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n\n    this._forgetRequest(request, false);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n    request._response = response;\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n  }\n\n  _forgetRequest(request, events) {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n\n    this._requestIdToRequest.delete(requestId);\n\n    this._attemptedAuthentications.delete(interceptionId);\n\n    if (events) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      this._requestIdToRequestPausedEvent.delete(requestId);\n    }\n  }\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n\n}\n\nexports.NetworkManager = NetworkManager;","map":{"version":3,"sources":["../../../../src/common/NetworkManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        /*\n         * There are four possible orders of events:\n         *  A. `_onRequestWillBeSent`\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n         *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n         *     (see crbug.com/1196004)\n         *\n         * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n         * optionally the `interceptionId` from `_onRequestPaused`.\n         *\n         * If request interception is disabled, call `_onRequest` once per call to\n         * `_onRequestWillBeSent`.\n         * If request interception is enabled, call `_onRequest` once per call to\n         * `_onRequestPaused` (once per `interceptionId`).\n         *\n         * Events are stored to allow for subsequent events to call `_onRequest`.\n         *\n         * Note that (chains of) redirect requests have the same `requestId` (!) as\n         * the original request. We have to anticipate series of events like these:\n         *  A. `_onRequestWillBeSent`,\n         *     `_onRequestWillBeSent`, ...\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *     (see crbug.com/1196004)\n         */\n        this._requestIdToRequestWillBeSentEvent = new Map();\n        this._requestIdToRequestPausedEvent = new Map();\n        this._requestIdToRequest = new Map();\n        this._extraHTTPHeaders = {};\n        this._credentials = null;\n        this._attemptedAuthentications = new Set();\n        this._userRequestInterceptionEnabled = false;\n        this._protocolRequestInterceptionEnabled = false;\n        this._userCacheDisabled = false;\n        this._emulatedNetworkConditions = {\n            offline: false,\n            upload: -1,\n            download: -1,\n            latency: 0,\n        };\n        this._client = client;\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._frameManager = frameManager;\n        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n    }\n    async initialize() {\n        await this._client.send('Network.enable');\n        if (this._ignoreHTTPSErrors)\n            await this._client.send('Security.setIgnoreCertificateErrors', {\n                ignore: true,\n            });\n    }\n    async authenticate(credentials) {\n        this._credentials = credentials;\n        await this._updateProtocolRequestInterception();\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        this._extraHTTPHeaders = {};\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            (0, assert_js_1.assert)(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            this._extraHTTPHeaders[key.toLowerCase()] = value;\n        }\n        await this._client.send('Network.setExtraHTTPHeaders', {\n            headers: this._extraHTTPHeaders,\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, this._extraHTTPHeaders);\n    }\n    numRequestsInProgress() {\n        return [...this._requestIdToRequest].filter(([, request]) => {\n            return !request.response();\n        }).length;\n    }\n    async setOfflineMode(value) {\n        this._emulatedNetworkConditions.offline = value;\n        await this._updateNetworkConditions();\n    }\n    async emulateNetworkConditions(networkConditions) {\n        this._emulatedNetworkConditions.upload = networkConditions\n            ? networkConditions.upload\n            : -1;\n        this._emulatedNetworkConditions.download = networkConditions\n            ? networkConditions.download\n            : -1;\n        this._emulatedNetworkConditions.latency = networkConditions\n            ? networkConditions.latency\n            : 0;\n        await this._updateNetworkConditions();\n    }\n    async _updateNetworkConditions() {\n        await this._client.send('Network.emulateNetworkConditions', {\n            offline: this._emulatedNetworkConditions.offline,\n            latency: this._emulatedNetworkConditions.latency,\n            uploadThroughput: this._emulatedNetworkConditions.upload,\n            downloadThroughput: this._emulatedNetworkConditions.download,\n        });\n    }\n    async setUserAgent(userAgent, userAgentMetadata) {\n        await this._client.send('Network.setUserAgentOverride', {\n            userAgent: userAgent,\n            userAgentMetadata: userAgentMetadata,\n        });\n    }\n    async setCacheEnabled(enabled) {\n        this._userCacheDisabled = !enabled;\n        await this._updateProtocolCacheDisabled();\n    }\n    async setRequestInterception(value) {\n        this._userRequestInterceptionEnabled = value;\n        await this._updateProtocolRequestInterception();\n    }\n    async _updateProtocolRequestInterception() {\n        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n        if (enabled === this._protocolRequestInterceptionEnabled)\n            return;\n        this._protocolRequestInterceptionEnabled = enabled;\n        if (enabled) {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.enable', {\n                    handleAuthRequests: true,\n                    patterns: [{ urlPattern: '*' }],\n                }),\n            ]);\n        }\n        else {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.disable'),\n            ]);\n        }\n    }\n    _cacheDisabled() {\n        return this._userCacheDisabled;\n    }\n    async _updateProtocolCacheDisabled() {\n        await this._client.send('Network.setCacheDisabled', {\n            cacheDisabled: this._cacheDisabled(),\n        });\n    }\n    _onRequestWillBeSent(event) {\n        // Request interception doesn't happen for data URLs with Network Service.\n        if (this._userRequestInterceptionEnabled &&\n            !event.request.url.startsWith('data:')) {\n            const requestId = event.requestId;\n            const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n            this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n            if (requestPausedEvent) {\n                const interceptionId = requestPausedEvent.requestId;\n                this._onRequest(event, interceptionId);\n                this._requestIdToRequestPausedEvent.delete(requestId);\n            }\n            return;\n        }\n        this._onRequest(event, null);\n    }\n    _onAuthRequired(event) {\n        let response = 'Default';\n        if (this._attemptedAuthentications.has(event.requestId)) {\n            response = 'CancelAuth';\n        }\n        else if (this._credentials) {\n            response = 'ProvideCredentials';\n            this._attemptedAuthentications.add(event.requestId);\n        }\n        const { username, password } = this._credentials || {\n            username: undefined,\n            password: undefined,\n        };\n        this._client\n            .send('Fetch.continueWithAuth', {\n            requestId: event.requestId,\n            authChallengeResponse: { response, username, password },\n        })\n            .catch(helper_js_1.debugError);\n    }\n    _onRequestPaused(event) {\n        if (!this._userRequestInterceptionEnabled &&\n            this._protocolRequestInterceptionEnabled) {\n            this._client\n                .send('Fetch.continueRequest', {\n                requestId: event.requestId,\n            })\n                .catch(helper_js_1.debugError);\n        }\n        const requestId = event.networkId;\n        const interceptionId = event.requestId;\n        if (!requestId) {\n            return;\n        }\n        let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n        // redirect requests have the same `requestId`,\n        if (requestWillBeSentEvent &&\n            (requestWillBeSentEvent.request.url !== event.request.url ||\n                requestWillBeSentEvent.request.method !== event.request.method)) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            requestWillBeSentEvent = null;\n        }\n        if (requestWillBeSentEvent) {\n            this._onRequest(requestWillBeSentEvent, interceptionId);\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n        }\n        else {\n            this._requestIdToRequestPausedEvent.set(requestId, event);\n        }\n    }\n    _onRequest(event, interceptionId) {\n        let redirectChain = [];\n        if (event.redirectResponse) {\n            const request = this._requestIdToRequest.get(event.requestId);\n            // If we connect late to the target, we could have missed the\n            // requestWillBeSent event.\n            if (request) {\n                this._handleRequestRedirect(request, event.redirectResponse);\n                redirectChain = request._redirectChain;\n            }\n        }\n        const frame = event.frameId\n            ? this._frameManager.frame(event.frameId)\n            : null;\n        const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n        this._requestIdToRequest.set(event.requestId, request);\n        this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n        request.finalizeInterceptions();\n    }\n    _onRequestServedFromCache(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        if (request)\n            request._fromMemoryCache = true;\n        this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);\n    }\n    _handleRequestRedirect(request, responsePayload) {\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n        request._response = response;\n        request._redirectChain.push(request);\n        response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n        this._forgetRequest(request, false);\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onResponseReceived(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // FileUpload sends a response without a matching request.\n        if (!request)\n            return;\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n        request._response = response;\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    }\n    _forgetRequest(request, events) {\n        const requestId = request._requestId;\n        const interceptionId = request._interceptionId;\n        this._requestIdToRequest.delete(requestId);\n        this._attemptedAuthentications.delete(interceptionId);\n        if (events) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            this._requestIdToRequestPausedEvent.delete(requestId);\n        }\n    }\n    _onLoadingFinished(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        // Under certain conditions we never get the Network.responseReceived\n        // event from protocol. @see https://crbug.com/883475\n        if (request.response())\n            request.response()._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onLoadingFailed(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        request._failureText = event.errorText;\n        const response = request.response();\n        if (response)\n            response._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n    }\n}\nexports.NetworkManager = NetworkManager;\n//# sourceMappingURL=NetworkManager.js.map"]},"metadata":{},"sourceType":"script"}